// API Configuration
const API_BASE_URL = 'https://tfd-cache.jeffistotallyawesome.space';
const LANGUAGE_CODE = 'en';

// Get API keys from environment or localStorage
const getApiKeys = () => {
  const workerApiKey = import.meta.env.VITE_WORKER_API_KEY || localStorage.getItem('workerApiKey');
  const nexonApiKey = import.meta.env.VITE_NEXON_API_KEY || localStorage.getItem('nexonApiKey');
  return { workerApiKey, nexonApiKey };
};

// State Management
class AppState {
  constructor() {
    this.descendants = [];
    this.modules = [];
    this.weapons = [];
    this.reactors = [];
    this.externalComponents = [];
    this.fellows = [];
    this.vehicles = [];
    this.archeTuningNodes = [];
    this.weaponTypes = [];
    this.tiers = [];
    this.stats = [];
    this.coreSlots = [];
    this.coreTypes = [];
    this.statLookup = {}; // Map stat_id to stat_name
    this.weaponTypeNameLookup = {}; // Map weapon_type_name to weapon_type
    this.coreSlotLookup = {}; // Map core_slot_id to core slot data
    this.coreTypeLookup = {}; // Map core_type_id to core type data
    this.currentDescendant = null;
    this.currentBuild = {
      triggerModule: null,
      descendantModules: Array(12).fill(null),
      weapons: Array(3).fill(null).map(() => ({
        weapon: null,
        modules: Array(10).fill(null),
        customStats: [],
        coreType: null,
        coreStats: [] // Array of { stat_id, stat_value }
      })),
      reactor: null,
      externalComponents: [],
      archeTuning: null,
      fellow: null,
      vehicle: null,
      inversionReinforcement: null
    };
    this.currentTab = 'modules';
    this.apiKeys = getApiKeys();
    this.dataLoaded = false;
    this.currentModuleSlot = null; // Track which module slot is being filled
    this.currentWeaponSlot = null; // Track which weapon slot is being filled (weapon or module)
  }

  setApiKeys(workerApiKey, nexonApiKey) {
    this.apiKeys = { workerApiKey, nexonApiKey };
    if (workerApiKey) localStorage.setItem('workerApiKey', workerApiKey);
    if (nexonApiKey) localStorage.setItem('nexonApiKey', nexonApiKey);
  }

  // Build stat lookup map
  buildStatLookup() {
    this.statLookup = {};
    if (this.stats && Array.isArray(this.stats)) {
      this.stats.forEach(stat => {
        if (stat.stat_id && stat.stat_name) {
          this.statLookup[stat.stat_id] = stat.stat_name;
        }
      });
    }
  }

  // Build weapon type lookup map
  buildWeaponTypeLookup() {
    this.weaponTypeNameLookup = {};
    if (this.weaponTypes && Array.isArray(this.weaponTypes)) {
      this.weaponTypes.forEach(weaponType => {
        if (weaponType.weapon_type_name && weaponType.weapon_type) {
          this.weaponTypeNameLookup[weaponType.weapon_type_name] = weaponType.weapon_type;
        }
      });
    }
  }

  // Get stat name by ID
  getStatName(statId) {
    return this.statLookup[statId] || statId || 'Unknown Stat';
  }

  // Get weapon type code from weapon type name
  getWeaponTypeCode(weaponTypeName) {
    return this.weaponTypeNameLookup[weaponTypeName] || null;
  }

  // Build core slot lookup map
  buildCoreSlotLookup() {
    this.coreSlotLookup = {};
    if (this.coreSlots && Array.isArray(this.coreSlots)) {
      this.coreSlots.forEach(coreSlot => {
        if (coreSlot.core_slot_id) {
          this.coreSlotLookup[coreSlot.core_slot_id] = coreSlot;
        }
      });
    }
  }

  // Build core type lookup map
  buildCoreTypeLookup() {
    this.coreTypeLookup = {};
    if (this.coreTypes && Array.isArray(this.coreTypes)) {
      this.coreTypes.forEach(coreType => {
        if (coreType.core_type_id) {
          this.coreTypeLookup[coreType.core_type_id] = coreType;
        }
      });
    }
  }

  // Get core slot by ID
  getCoreSlot(coreSlotId) {
    return this.coreSlotLookup[coreSlotId] || null;
  }

  // Get core type by ID
  getCoreType(coreTypeId) {
    return this.coreTypeLookup[coreTypeId] || null;
  }
}

const state = new AppState();

// API Client
class TFDApiClient {
  constructor(baseUrl) {
    this.baseUrl = baseUrl;
  }

  async fetchMetadata(type, languageCode = LANGUAGE_CODE) {
    try {
      const url = `${this.baseUrl}/tfd/metadata/${type}?language_code=${languageCode}`;
      
      console.log(`Fetching metadata: ${type} from ${url}`);
      
      // Build headers with API keys
      const headers = {};
      if (state.apiKeys.workerApiKey) {
        headers['x-worker-api-key'] = state.apiKeys.workerApiKey;
      }
      if (state.apiKeys.nexonApiKey) {
        headers['x-nxopen-api-key'] = state.apiKeys.nexonApiKey;
      }
      
      const response = await fetch(url, { headers });
      
      if (!response.ok) {
        if (response.status === 401) {
          throw new Error('Authentication failed. Please configure your API keys.');
        }
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      
      const data = await response.json();
      console.log(`${type} metadata loaded:`, data?.length || Object.keys(data || {}).length, 'items');
      return data;
    } catch (error) {
      console.error(`Error fetching ${type}:`, error);
      throw error;
    }
  }

  async getDescendants() {
    return this.fetchMetadata('descendant');
  }

  async getModules() {
    return this.fetchMetadata('module');
  }

  async getWeapons() {
    return this.fetchMetadata('weapon');
  }

  async getReactors() {
    return this.fetchMetadata('reactor');
  }

  async getExternalComponents() {
    return this.fetchMetadata('external-component');
  }

  async getStatTypes() {
    return this.fetchMetadata('stat');
  }

  async getFellows() {
    return this.fetchMetadata('fellow');
  }

  async getVehicles() {
    return this.fetchMetadata('vehicle');
  }

  async getArcheTuningNodes() {
    return this.fetchMetadata('arche-tuning-node');
  }

  async getWeaponTypes() {
    return this.fetchMetadata('weapon-type');
  }

  async getTiers() {
    return this.fetchMetadata('tier');
  }

  async getCoreSlots() {
    return this.fetchMetadata('core-slot');
  }

  async getCoreTypes() {
    return this.fetchMetadata('core-type');
  }
}

const apiClient = new TFDApiClient(API_BASE_URL);

// UI Components
class UIComponents {
  static createModuleSlot(index, module = null) {
    const slot = document.createElement('div');
    slot.className = `module-slot ${module ? 'filled' : ''}`;
    slot.dataset.index = index;
    
    if (module) {
      slot.innerHTML = `
        ${module.image_url ? `
          <div class="w-full aspect-square mb-2 rounded overflow-hidden bg-tfd-darker">
            <img src="${module.image_url}" alt="${module.module_name}" class="w-full h-full object-cover" loading="lazy">
          </div>
        ` : ''}
        <div class="font-bold text-tfd-primary text-xs mb-1 truncate" title="${module.module_name || 'Module'}">${module.module_name || 'Module'}</div>
        <div class="text-xs text-gray-400">${module.module_type || 'Type'}</div>
        <div class="mt-1 text-xs text-tfd-accent">${module.module_tier_id || ''}</div>
      `;
    } else {
      slot.innerHTML = `
        <div class="text-center text-gray-500 py-4">
          <div class="text-2xl mb-1">+</div>
          <div class="text-xs">Slot ${index + 1}</div>
        </div>
      `;
    }
    
    slot.addEventListener('click', () => {
      app.openModuleSelector(index);
    });
    
    return slot;
  }

  static createWeaponCard(weaponIndex) {
    const weaponData = state.currentBuild.weapons[weaponIndex];
    const weapon = weaponData?.weapon;
    const card = document.createElement('div');
    card.className = 'weapon-card';
    
    card.innerHTML = `
      <div class="flex items-center justify-between mb-4">
        <h4 class="text-xl font-bold text-tfd-secondary">
          <svg class="w-5 h-5 inline mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path>
          </svg>
          Weapon ${weaponIndex + 1}
        </h4>
        <button class="btn-secondary text-xs py-1 px-3" onclick="app.openWeaponSelector(${weaponIndex})">
          ${weapon ? 'Change' : 'Select Weapon'}
        </button>
      </div>

      ${weapon ? `
        <div class="mb-4">
          ${weapon.image_url ? `
            <div class="w-full h-32 mb-3 rounded overflow-hidden bg-tfd-darker flex items-center justify-center">
              <img src="${weapon.image_url}" alt="${weapon.weapon_name}" class="max-w-full max-h-full object-contain" loading="lazy">
            </div>
          ` : ''}
          <div class="text-tfd-primary font-bold mb-2">${weapon.weapon_name || 'Weapon Name'}</div>
          <div class="text-sm text-gray-400 mb-2">${weapon.weapon_type || 'Type'} - ${weapon.weapon_tier_id?.replace('Tier', 'Tier ') || 'Tier'}</div>
        </div>

        <!-- Weapon Stats -->
        <div class="mb-4">
          <h5 class="text-sm font-bold text-gray-300 mb-2">Base Stats</h5>
          <div class="grid grid-cols-2 gap-2" id="weapon-${weaponIndex}-stats">
            ${weapon.base_stat && weapon.base_stat.length > 0 ? 
              weapon.base_stat.slice(0, 6).map(stat => `
                <div class="bg-tfd-darker p-2 rounded text-xs">
                  <div class="text-gray-400">${state.getStatName(stat.stat_id)}</div>
                  <div class="text-tfd-primary font-bold">${stat.stat_value}</div>
                </div>
              `).join('') : 
              '<div class="col-span-2 text-xs text-gray-500 text-center">No base stats</div>'
            }
          </div>
        </div>

        <!-- Custom Stats -->
        <div class="mb-4">
          <h5 class="text-sm font-bold text-gray-300 mb-2">Custom Stats (4 slots)</h5>
          <div class="grid grid-cols-2 gap-2">
            ${[0, 1, 2, 3].map(i => {
              const customStat = weaponData.customStats[i] || null;
              return `
                <div class="bg-tfd-darker p-2 rounded">
                  ${customStat ? `
                    <div class="flex items-center justify-between">
                      <div class="flex-1">
                        <div class="text-xs text-gray-400">${state.getStatName(customStat.stat_id)}</div>
                        <div class="text-sm text-tfd-primary font-bold">${customStat.stat_value}</div>
                      </div>
                      <button 
                        onclick="app.removeCustomStat(${weaponIndex}, ${i})" 
                        class="text-red-500 hover:text-red-400 text-lg leading-none ml-2"
                        title="Remove stat"
                      >&times;</button>
                    </div>
                  ` : `
                    <button class="w-full text-xs text-left text-tfd-secondary hover:text-tfd-primary py-1" 
                            onclick="app.openCustomStatSelector(${weaponIndex}, ${i})">
                      + Add Custom Stat
                    </button>
                  `}
                </div>
              `;
            }).join('')}
          </div>
        </div>

        <!-- Weapon Core -->
        <div class="mb-4">
          <h5 class="text-sm font-bold text-gray-300 mb-2">Weapon Core</h5>
          ${weapon.available_core_slot && weapon.available_core_slot.length > 0 ? `
            <div class="bg-tfd-darker p-3 rounded">
              <button class="w-full text-left text-sm text-tfd-secondary hover:text-tfd-primary" 
                      onclick="app.openCoreTypeSelector(${weaponIndex})">
                ${weaponData.coreType ? `
                  <div class="text-tfd-primary font-bold mb-2">${state.getCoreType(weaponData.coreType)?.core_type || 'Unknown Core'}</div>
                  ${weaponData.coreStats && weaponData.coreStats.length > 0 ? `
                    <div class="space-y-1">
                      ${weaponData.coreStats.map(coreStat => `
                        <div class="text-xs text-gray-400">
                          <span class="text-tfd-accent">${state.getStatName(coreStat.stat_id)}:</span> 
                          <span class="text-tfd-primary font-bold">${coreStat.stat_value}</span>
                        </div>
                      `).join('')}
                    </div>
                  ` : '<div class="text-xs text-gray-500">Click to configure core stats</div>'}
                ` : '+ Select Core Type'}
              </button>
            </div>
          ` : '<div class="text-xs text-gray-500 text-center py-2">No core slot available</div>'}
        </div>

        <!-- Weapon Modules -->
        <div>
          <h5 class="text-sm font-bold text-gray-300 mb-2">Weapon Modules (10 Slots)</h5>
          <div class="grid grid-cols-5 gap-2" id="weapon-${weaponIndex}-modules">
            <!-- Populated by renderWeapons -->
          </div>
        </div>
      ` : `
        <div class="text-center py-8 text-gray-500">
          <svg class="w-16 h-16 mx-auto mb-3 opacity-30" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path>
          </svg>
          <p>No weapon selected</p>
          <p class="text-xs mt-1">Click Select to choose a weapon</p>
        </div>
      `}
    `;
    
    return card;
  }

  static createStatPlaceholders(count) {
    return Array(count).fill(0).map((_, i) => 
      `<div class="bg-tfd-darker p-2 rounded text-xs">
        <div class="text-gray-400">Stat ${i + 1}</div>
        <div class="text-tfd-primary font-bold">--</div>
      </div>`
    ).join('');
  }

  static createDescendantCard(descendant) {
    const card = document.createElement('div');
    card.className = 'card cursor-pointer hover:scale-105 transition-transform';
    card.innerHTML = `
      <div class="aspect-square bg-tfd-darker rounded mb-2 overflow-hidden">
        ${descendant.descendant_image_url ? `
          <img src="${descendant.descendant_image_url}" alt="${descendant.descendant_name}" class="w-full h-full object-cover" loading="lazy">
        ` : `
          <div class="w-full h-full flex items-center justify-center">
            <svg class="w-12 h-12 text-tfd-primary/50" fill="currentColor" viewBox="0 0 20 20">
              <path d="M10 9a3 3 0 100-6 3 3 0 000 6zm-7 9a7 7 0 1114 0H3z"></path>
            </svg>
          </div>
        `}
      </div>
      <div class="text-center">
        <div class="font-bold text-sm text-tfd-primary truncate" title="${descendant.descendant_name || 'Unknown'}">${descendant.descendant_name || 'Unknown'}</div>
      </div>
    `;
    
    card.addEventListener('click', () => {
      app.selectDescendant(descendant);
    });
    
    return card;
  }

  static showLoading() {
    document.getElementById('loading')?.classList.remove('hidden');
    document.getElementById('error')?.classList.add('hidden');
    document.getElementById('build-container')?.classList.add('hidden');
  }

  static hideLoading() {
    document.getElementById('loading')?.classList.add('hidden');
  }

  static showError(message) {
    const errorEl = document.getElementById('error');
    const errorMessageEl = document.getElementById('error-message');
    
    if (errorEl && errorMessageEl) {
      errorMessageEl.textContent = message;
      errorEl.classList.remove('hidden');
    }
    
    UIComponents.hideLoading();
  }

  static showBuildContainer() {
    document.getElementById('build-container')?.classList.remove('hidden');
  }
}

// Application Logic
class Application {
  async init() {
    try {
      UIComponents.showLoading();
      
      // Check if API keys are configured
      if (!state.apiKeys.workerApiKey || !state.apiKeys.nexonApiKey) {
        UIComponents.hideLoading();
        UIComponents.showError('API keys not configured. Please click Settings to add your API keys.');
        return;
      }
      
      // Load all metadata in parallel for better performance
      console.log('Loading all metadata...');
      const [
        descendants,
        modules,
        weapons,
        reactors,
        externalComponents,
        fellows,
        vehicles,
        archeTuningNodes,
        weaponTypes,
        tiers,
        stats,
        coreSlots,
        coreTypes
      ] = await Promise.all([
        apiClient.getDescendants(),
        apiClient.getModules(),
        apiClient.getWeapons(),
        apiClient.getReactors(),
        apiClient.getExternalComponents(),
        apiClient.getFellows(),
        apiClient.getVehicles(),
        apiClient.getArcheTuningNodes(),
        apiClient.getWeaponTypes(),
        apiClient.getTiers(),
        apiClient.getStatTypes(),
        apiClient.getCoreSlots(),
        apiClient.getCoreTypes()
      ]);
      
      // Store all data in state
      state.descendants = descendants || [];
      state.modules = modules || [];
      state.weapons = weapons || [];
      state.reactors = reactors || [];
      state.externalComponents = externalComponents || [];
      state.fellows = fellows || [];
      state.vehicles = vehicles || [];
      state.archeTuningNodes = archeTuningNodes || [];
      state.weaponTypes = weaponTypes || [];
      state.tiers = tiers || [];
      state.stats = stats || [];
      state.coreSlots = coreSlots || [];
      state.coreTypes = coreTypes || [];
      state.buildStatLookup();
      state.buildWeaponTypeLookup();
      state.buildCoreSlotLookup();
      state.buildCoreTypeLookup();
      state.dataLoaded = true;
      
      console.log('Metadata loaded:', {
        descendants: state.descendants.length,
        modules: state.modules.length,
        weapons: state.weapons.length,
        reactors: state.reactors.length,
        externalComponents: state.externalComponents.length,
        fellows: state.fellows.length,
        vehicles: state.vehicles.length,
        archeTuningNodes: state.archeTuningNodes.length,
        weaponTypes: state.weaponTypes.length,
        tiers: state.tiers.length,
        stats: state.stats.length,
        coreSlots: state.coreSlots.length,
        coreTypes: state.coreTypes.length
      });
      
      // Render descendants
      const container = document.getElementById('descendant-selector');
      if (container) {
        container.innerHTML = '';
        
        if (state.descendants.length === 0) {
          container.innerHTML = '<p class="col-span-full text-center text-gray-400">No descendants found</p>';
        } else {
          state.descendants.forEach(descendant => {
            container.appendChild(UIComponents.createDescendantCard(descendant));
          });
        }
      }
      
      UIComponents.hideLoading();
    } catch (error) {
      console.error('Initialization error:', error);
      
      // Check for authentication error
      if (error.message.includes('Authentication failed')) {
        UIComponents.showError('Authentication failed. Please check your API keys in Settings.');
      } else {
        UIComponents.showError('Failed to load data. Please check your connection and try again.');
      }
    }
  }

  async loadDescendants() {
    // Reload descendants and update display
    try {
      UIComponents.showLoading();
      
      const data = await apiClient.getDescendants();
      state.descendants = data || [];
      
      const container = document.getElementById('descendant-selector');
      if (container) {
        container.innerHTML = '';
        
        if (state.descendants.length === 0) {
          container.innerHTML = '<p class="col-span-full text-center text-gray-400">No descendants found</p>';
        } else {
          state.descendants.forEach(descendant => {
            container.appendChild(UIComponents.createDescendantCard(descendant));
          });
        }
      }
      
      UIComponents.hideLoading();
    } catch (error) {
      console.error('Error loading descendants:', error);
      UIComponents.showError('Failed to reload descendants.');
    }
  }

  async selectDescendant(descendant) {
    state.currentDescendant = descendant;
    
    // Update UI
    const nameEl = document.getElementById('descendant-name');
    const descEl = document.getElementById('descendant-description');
    const imageEl = document.getElementById('descendant-image');
    
    if (nameEl) nameEl.textContent = descendant.descendant_name || 'Unknown Descendant';
    
    // Display first skill description or create a summary
    let description = 'No description available';
    if (descendant.descendant_skill && descendant.descendant_skill.length > 0) {
      const skills = descendant.descendant_skill.map(s => s.skill_name).join(', ');
      description = `Skills: ${skills}`;
    }
    if (descEl) descEl.textContent = description;
    
    // Update image
    if (imageEl && descendant.descendant_image_url) {
      imageEl.innerHTML = `<img src="${descendant.descendant_image_url}" alt="${descendant.descendant_name}" class="w-full h-full object-cover rounded-lg" loading="lazy">`;
    }
    
    // Initialize build for this descendant
    this.initializeBuild();
    
    // Show build container
    UIComponents.showBuildContainer();
    
    // Switch to modules tab
    this.switchTab('modules');
  }

  initializeBuild() {
    // Reset build
    state.currentBuild = {
      triggerModule: null,
      descendantModules: Array(12).fill(null),
      weapons: Array(3).fill(null).map(() => ({
        weapon: null,
        modules: Array(10).fill(null),
        customStats: [],
        coreType: null,
        coreStats: []
      })),
      reactor: null,
      externalComponents: [],
      archeTuning: null,
      fellow: null,
      vehicle: null,
      inversionReinforcement: null
    };
    
    // Render modules
    this.renderModules();
    
    // Render weapons
    this.renderWeapons();
    
    // Render other components
    this.renderExternalComponents();
  }

  renderModules() {
    // Render trigger module
    const triggerContainer = document.getElementById('trigger-module-slot');
    if (triggerContainer) {
      const triggerModule = state.currentBuild.triggerModule;
      triggerContainer.innerHTML = '';
      
      const triggerSlot = document.createElement('div');
      triggerSlot.className = 'module-slot cursor-pointer';
      triggerSlot.onclick = () => this.openModuleSelector(-1, 'Trigger');
      
      if (triggerModule) {
        triggerSlot.innerHTML = `
          <div class="relative h-full">
            ${triggerModule.image_url 
              ? `<img src="${triggerModule.image_url}" alt="${triggerModule.module_name}" class="w-full h-full object-cover rounded-lg">`
              : '<div class="w-full h-full bg-gray-800 rounded-lg flex items-center justify-center"><span class="text-gray-600">No Image</span></div>'
            }
            <div class="absolute inset-0 bg-gradient-to-t from-black/80 via-transparent to-transparent rounded-lg"></div>
            <div class="absolute bottom-0 left-0 right-0 p-2">
              <p class="text-xs font-bold text-tfd-primary">${triggerModule.module_name}</p>
              ${triggerModule.module_tier_id ? `<p class="text-xs text-gray-400">${triggerModule.module_tier_id.replace('Tier', 'Tier ')}</p>` : ''}
            </div>
            <div class="absolute top-2 right-2 px-2 py-1 text-xs rounded ${
              triggerModule.module_socket_type === 'Almandine' ? 'bg-red-600' :
              triggerModule.module_socket_type === 'Malachite' ? 'bg-green-600' :
              triggerModule.module_socket_type === 'Cerulean' ? 'bg-blue-600' :
              triggerModule.module_socket_type === 'Xantic' ? 'bg-yellow-600' :
              triggerModule.module_socket_type === 'Rutile' ? 'bg-purple-600' :
              'bg-gray-500'
            }">
              ${triggerModule.module_socket_type || 'N/A'}
            </div>
          </div>
        `;
      } else {
        triggerSlot.innerHTML = `
          <div class="text-gray-500 text-center">
            <div class="text-2xl mb-2">âš¡</div>
            <p class="text-sm">Click to add<br>Trigger Module</p>
          </div>
        `;
      }
      
      triggerContainer.appendChild(triggerSlot);
    }
    
    // Render 12 descendant module slots
    const container = document.getElementById('descendant-modules');
    if (!container) return;
    
    container.innerHTML = '';
    
    for (let i = 0; i < 12; i++) {
      const module = state.currentBuild.descendantModules[i];
      
      // Determine slot type and restrictions
      let slotType, slotLabel, allowedTypes;
      if (i === 0) {
        slotType = 'Skill';
        slotLabel = 'Skill Slot';
        allowedTypes = 'Skill Modules';
      } else if (i === 6) {
        slotType = 'Sub';
        slotLabel = 'Sub Slot';
        allowedTypes = 'Sub Modules';
      } else {
        slotType = 'Main';
        slotLabel = `Module Slot ${i + 1}`;
        allowedTypes = 'Main Modules';
      }
      
      const slot = document.createElement('div');
      slot.className = 'module-slot cursor-pointer';
      slot.onclick = () => this.openModuleSelector(i, slotType);
      
      if (module) {
        slot.innerHTML = `
          <div class="relative h-full">
            ${module.image_url 
              ? `<img src="${module.image_url}" alt="${module.module_name}" class="w-full h-full object-cover rounded-lg">`
              : '<div class="w-full h-full bg-gray-800 rounded-lg flex items-center justify-center"><span class="text-gray-600">No Image</span></div>'
            }
            <div class="absolute inset-0 bg-gradient-to-t from-black/80 via-transparent to-transparent rounded-lg"></div>
            <div class="absolute bottom-0 left-0 right-0 p-2">
              <p class="text-xs font-bold text-tfd-primary">${module.module_name}</p>
              ${module.module_tier ? `<p class="text-xs text-gray-400">Tier ${module.module_tier}</p>` : ''}
            </div>
            <div class="absolute top-2 right-2 px-2 py-1 text-xs rounded ${
              module.module_socket_type === 'Almandine' ? 'bg-red-600' :
              module.module_socket_type === 'Malachite' ? 'bg-green-600' :
              module.module_socket_type === 'Cerulean' ? 'bg-blue-600' :
              module.module_socket_type === 'Xantic' ? 'bg-yellow-600' :
              module.module_socket_type === 'Rutile' ? 'bg-purple-600' :
              'bg-gray-500'
            }">
              ${module.module_socket_type || 'N/A'}
            </div>
          </div>
        `;
      } else {
        slot.innerHTML = `
          <div class="text-gray-500 text-center">
            <div class="text-2xl mb-2">+</div>
            <p class="text-xs font-semibold">${slotLabel}</p>
            <p class="text-xs mt-1">${allowedTypes}</p>
          </div>
        `;
      }
      
      container.appendChild(slot);
    }
  }

  renderWeapons() {
    const container = document.getElementById('weapons-container');
    if (!container) return;
    
    container.innerHTML = '';
    
    for (let i = 0; i < 3; i++) {
      const weaponCard = UIComponents.createWeaponCard(i);
      container.appendChild(weaponCard);
      
      // Render weapon modules if weapon is selected
      const weaponData = state.currentBuild.weapons[i];
      if (weaponData?.weapon) {
        const modulesContainer = document.getElementById(`weapon-${i}-modules`);
        if (modulesContainer) {
          modulesContainer.innerHTML = '';
          for (let j = 0; j < 10; j++) {
            const module = weaponData.modules[j];
            const slot = document.createElement('div');
            slot.className = 'module-slot cursor-pointer text-center py-2';
            slot.onclick = () => app.openWeaponModuleSelector(i, j);
            
            if (module) {
              slot.innerHTML = `
                <div class="relative h-full">
                  ${module.image_url ? 
                    `<img src="${module.image_url}" alt="${module.module_name}" class="w-full h-full object-cover rounded" loading="lazy">` :
                    `<div class="text-xs text-tfd-primary truncate px-1">${module.module_name}</div>`
                  }
                </div>
              `;
            } else {
              slot.innerHTML = '<div class="text-gray-500 text-xs">+</div>';
            }
            
            modulesContainer.appendChild(slot);
          }
        }
      }
    }
  }

  renderExternalComponents() {
    const container = document.getElementById('external-components');
    if (!container) return;
    
    container.innerHTML = `
      <div class="module-slot p-4 text-center">
        <div class="text-gray-500 mb-2">
          <svg class="w-8 h-8 mx-auto" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path>
          </svg>
        </div>
        <p class="text-sm text-gray-400">Add Component</p>
      </div>
    `.repeat(4);
  }

  switchTab(tabName) {
    state.currentTab = tabName;
    
    // Update tab buttons
    document.querySelectorAll('.tab').forEach(tab => {
      tab.classList.remove('active');
      if (tab.dataset.tab === tabName) {
        tab.classList.add('active');
      }
    });
    
    // Update tab content
    document.querySelectorAll('.tab-content').forEach(content => {
      content.classList.add('hidden');
    });
    
    const activeContent = document.getElementById(`tab-${tabName}`);
    if (activeContent) {
      activeContent.classList.remove('hidden');
    }
  }

  openModuleSelector(index) {
    // TODO: Implement module selector modal
    console.log('Open module selector for slot:', index);
    alert(`Module selector for slot ${index + 1} - Coming soon!`);
  }

  selectWeapon(weaponIndex) {
    // TODO: Implement weapon selector
    console.log('Select weapon for slot:', weaponIndex);
    alert(`Weapon selector for slot ${weaponIndex + 1} - Coming soon!`);
  }

  createNewBuild() {
    if (confirm('Create a new build? This will reset your current build.')) {
      state.currentDescendant = null;
      state.currentBuild = {
        triggerModule: null,
        descendantModules: Array(12).fill(null),
        weapons: Array(3).fill(null).map(() => ({
          weapon: null,
          modules: Array(10).fill(null),
          customStats: [],
          coreType: null,
          coreStats: []
        })),
        reactor: null,
        externalComponents: [],
        archeTuning: null,
        fellow: null,
        vehicle: null,
        inversionReinforcement: null
      };
      
      document.getElementById('build-container')?.classList.add('hidden');
      window.scrollTo({ top: 0, behavior: 'smooth' });
    }
  }

  openSettings() {
    const modal = document.getElementById('settings-modal');
    const workerKeyInput = document.getElementById('worker-api-key');
    const nexonKeyInput = document.getElementById('nexon-api-key');
    
    if (modal && workerKeyInput && nexonKeyInput) {
      // Pre-fill with existing keys
      workerKeyInput.value = state.apiKeys.workerApiKey || '';
      nexonKeyInput.value = state.apiKeys.nexonApiKey || '';
      
      modal.classList.remove('hidden');
    }
  }

  closeSettings() {
    const modal = document.getElementById('settings-modal');
    if (modal) {
      modal.classList.add('hidden');
    }
  }

  saveSettings() {
    const workerKeyInput = document.getElementById('worker-api-key');
    const nexonKeyInput = document.getElementById('nexon-api-key');
    
    if (workerKeyInput && nexonKeyInput) {
      const workerKey = workerKeyInput.value.trim();
      const nexonKey = nexonKeyInput.value.trim();
      
      if (!workerKey || !nexonKey) {
        alert('Please enter both API keys.');
        return;
      }
      
      state.setApiKeys(workerKey, nexonKey);
      this.closeSettings();
      
      // Reload data with new keys
      this.init();
    }
  }

  openModuleSelector(slotIndex, slotType) {
    // Store the current slot context
    state.currentModuleSlot = { index: slotIndex, type: slotType };
    
    // Show the modal
    const modal = document.getElementById('module-selector-modal');
    if (modal) {
      modal.classList.remove('hidden');
    }
    
    // Update slot info text
    const slotInfo = document.getElementById('module-slot-info');
    if (slotInfo) {
      let infoText = '';
      if (slotType === 'Trigger') {
        infoText = 'Trigger Module Slot - Trigger modules only';
      } else if (slotType === 'Skill') {
        infoText = 'Slot 1 - Skill modules only';
      } else if (slotType === 'Sub') {
        infoText = 'Slot 7 - Sub modules only';
      } else {
        infoText = `Slot ${slotIndex + 1} - Main modules`;
      }
      
      const countSpan = slotInfo.querySelector('#module-count');
      if (countSpan) {
        slotInfo.innerHTML = `${infoText} | <span id="module-count">Loading...</span>`;
      } else {
        slotInfo.textContent = infoText;
      }
    }
    
    // Clear search and filters
    const searchInput = document.getElementById('module-search');
    if (searchInput) {
      searchInput.value = '';
      searchInput.focus(); // Focus the search input
    }
    
    // Reset filter buttons
    document.querySelectorAll('.module-filter-btn[data-socket]').forEach(btn => {
      btn.classList.remove('active');
    });
    document.querySelector('.module-filter-btn[data-socket="all"]')?.classList.add('active');
    
    document.querySelectorAll('.module-filter-btn[data-tier]').forEach(btn => {
      btn.classList.remove('active');
    });
    document.querySelector('.module-filter-btn[data-tier="all"]')?.classList.add('active');
    
    // Render modules based on slot type
    this.renderModuleSelectorGrid(slotType);
  }

  closeModuleSelector() {
    const modal = document.getElementById('module-selector-modal');
    if (modal) {
      modal.classList.add('hidden');
    }
    state.currentModuleSlot = null;
    state.currentWeaponSlot = null;
  }

  renderModuleSelectorGrid(slotType = null, searchQuery = '', socketFilter = 'all', tierFilter = 'all') {
    // Check if this is for a weapon module
    if (state.currentWeaponSlot?.type === 'module') {
      this.renderWeaponModuleSelectorGrid(searchQuery, socketFilter, tierFilter);
      return;
    }
    
    const grid = document.getElementById('module-selector-grid');
    if (!grid) return;
    
    console.log('renderModuleSelectorGrid called:', { slotType, searchQuery, socketFilter, tierFilter, totalModules: state.modules.length });
    
    // Log sample module to see structure
    if (state.modules.length > 0) {
      console.log('Sample module:', state.modules[0]);
    }
    
    // Filter modules
    let filteredModules = state.modules.filter(module => {
      // First filter: Only Descendant modules for descendant slots
      if (module.module_class !== 'Descendant') {
        return false;
      }
      
      // Filter by slot type using available_module_slot_type
      if (slotType && module.available_module_slot_type) {
        const hasSlotType = module.available_module_slot_type.includes(slotType);
        if (!hasSlotType) {
          return false;
        }
      }
      
      // Filter by descendant for Skill and Ancestors modules
      // If module has available_descendant_id list, check if current descendant is in it
      if (module.available_descendant_id && module.available_descendant_id.length > 0) {
        if (!state.currentDescendant || !state.currentDescendant.descendant_id) {
          return false; // No descendant selected, can't show descendant-specific modules
        }
        
        const isAvailableForDescendant = module.available_descendant_id.includes(state.currentDescendant.descendant_id);
        if (!isAvailableForDescendant) {
          return false; // Module not available for this descendant
        }
      }
      
      // Filter by search query
      if (searchQuery && !module.module_name.toLowerCase().includes(searchQuery.toLowerCase())) {
        return false;
      }
      
      // Filter by socket type
      if (socketFilter !== 'all' && module.module_socket_type !== socketFilter) {
        return false;
      }
      
      // Filter by tier
      if (tierFilter !== 'all' && module.module_tier_id !== tierFilter) {
        return false;
      }
      
      return true;
    });
    
    console.log('Filtered modules:', filteredModules.length);
    
    // Sort modules by name
    filteredModules.sort((a, b) => a.module_name.localeCompare(b.module_name));
    
    // Render modules
    grid.innerHTML = filteredModules.map(module => `
      <div class="module-card cursor-pointer hover:scale-105 transition-transform" 
           data-module-id="${module.module_id}"
           onclick="app.selectModule('${module.module_id}')">
        <div class="relative">
          ${module.image_url 
            ? `<img src="${module.image_url}" alt="${module.module_name}" class="w-full h-32 object-cover rounded-t-lg">`
            : '<div class="w-full h-32 bg-gray-800 rounded-t-lg flex items-center justify-center"><span class="text-gray-600">No Image</span></div>'
          }
          <div class="absolute top-2 right-2 px-2 py-1 text-xs rounded ${
            module.module_socket_type === 'Almandine' ? 'bg-red-600' :
            module.module_socket_type === 'Malachite' ? 'bg-green-600' :
            module.module_socket_type === 'Cerulean' ? 'bg-blue-600' :
            module.module_socket_type === 'Xantic' ? 'bg-yellow-600' :
            module.module_socket_type === 'Rutile' ? 'bg-purple-600' :
            'bg-gray-500'
          }">
            ${module.module_socket_type || 'N/A'}
          </div>
        </div>
        <div class="p-3">
          <h4 class="font-bold text-sm mb-1 text-tfd-primary">${module.module_name}</h4>
          <div class="text-xs text-gray-400 space-y-1">
            ${module.module_tier_id ? `<div>${module.module_tier_id.replace('Tier', 'Tier ')}</div>` : ''}
            ${module.available_module_slot_type?.length > 0 ? `<div>Slot: ${module.available_module_slot_type.join(', ')}</div>` : ''}
            ${module.module_type ? `<div class="text-tfd-accent">Type: ${module.module_type}</div>` : ''}
          </div>
        </div>
      </div>
    `).join('');
    
    // Show count
    const countEl = document.getElementById('module-count');
    if (countEl) {
      countEl.textContent = `${filteredModules.length} modules`;
    }
  }

  selectModule(moduleId) {
    if (!state.currentModuleSlot) return;
    
    const module = state.modules.find(m => m.module_id === moduleId);
    if (!module) return;
    
    // Check if module_type is unique (if module_type is not null)
    if (module.module_type) {
      // Check in trigger slot
      if (state.currentBuild.triggerModule && 
          state.currentBuild.triggerModule.module_type === module.module_type && 
          state.currentModuleSlot.index !== -1) {
        alert(`A module with type "${module.module_type}" is already equipped in Trigger Slot. Only one module of each type is allowed per build.`);
        return;
      }
      
      // Check in descendant modules
      const duplicateIndex = state.currentBuild.descendantModules.findIndex((m, idx) => 
        m && m.module_type === module.module_type && idx !== state.currentModuleSlot.index
      );
      
      if (duplicateIndex !== -1) {
        alert(`A module with type "${module.module_type}" is already equipped in Slot ${duplicateIndex + 1}. Only one module of each type is allowed per build.`);
        return;
      }
    }
    
    // Assign module to the appropriate slot
    if (state.currentModuleSlot.index === -1) {
      // Trigger slot
      state.currentBuild.triggerModule = module;
    } else {
      // Regular descendant module slot
      state.currentBuild.descendantModules[state.currentModuleSlot.index] = module;
    }
    
    // Close the modal
    this.closeModuleSelector();
    
    // Re-render the modules view
    this.renderModules();
  }

  filterModules() {
    const searchInput = document.getElementById('module-search');
    const searchQuery = searchInput ? searchInput.value : '';
    
    // Get active socket filter
    const activeSocketFilter = document.querySelector('.module-filter-btn.active[data-socket]');
    const socketFilter = activeSocketFilter ? activeSocketFilter.dataset.socket : 'all';
    
    // Get active tier filter
    const activeTierFilter = document.querySelector('.module-filter-btn.active[data-tier]');
    const tierFilter = activeTierFilter ? activeTierFilter.dataset.tier : 'all';
    
    // Get current slot type
    const slotType = state.currentModuleSlot ? state.currentModuleSlot.type : null;
    
    this.renderModuleSelectorGrid(slotType, searchQuery, socketFilter, tierFilter);
  }

  filterModulesBySocket(socket) {
    // Update button states for socket filters
    document.querySelectorAll('.module-filter-btn[data-socket]').forEach(btn => {
      if (btn.dataset.socket === socket) {
        btn.classList.add('active');
      } else {
        btn.classList.remove('active');
      }
    });
    
    // Filter modules
    this.filterModules();
  }

  filterModulesByTier(tier) {
    // Update button states for tier filters
    document.querySelectorAll('.module-filter-btn[data-tier]').forEach(btn => {
      if (btn.dataset.tier === tier) {
        btn.classList.add('active');
      } else {
        btn.classList.remove('active');
      }
    });
    
    // Filter modules
    this.filterModules();
  }

  // Weapon Selector Methods
  openWeaponSelector(weaponIndex) {
    state.currentWeaponSlot = { index: weaponIndex, type: 'weapon' };
    
    const modal = document.getElementById('weapon-selector-modal');
    if (modal) {
      modal.classList.remove('hidden');
    }
    
    const slotInfo = document.getElementById('weapon-slot-info');
    if (slotInfo) {
      const countSpan = slotInfo.querySelector('#weapon-count');
      if (countSpan) {
        slotInfo.innerHTML = `Weapon Slot ${weaponIndex + 1} | <span id="weapon-count">Loading...</span>`;
      } else {
        slotInfo.textContent = `Weapon Slot ${weaponIndex + 1}`;
      }
    }
    
    const searchInput = document.getElementById('weapon-search');
    if (searchInput) {
      searchInput.value = '';
      searchInput.focus();
    }
    
    // Reset filters
    document.querySelectorAll('.module-filter-btn[data-weapon-type]').forEach(btn => {
      btn.classList.remove('active');
    });
    document.querySelector('.module-filter-btn[data-weapon-type="all"]')?.classList.add('active');
    
    document.querySelectorAll('.module-filter-btn[data-weapon-tier]').forEach(btn => {
      btn.classList.remove('active');
    });
    document.querySelector('.module-filter-btn[data-weapon-tier="all"]')?.classList.add('active');
    
    this.renderWeaponSelectorGrid();
  }

  closeWeaponSelector() {
    const modal = document.getElementById('weapon-selector-modal');
    if (modal) {
      modal.classList.add('hidden');
    }
    state.currentWeaponSlot = null;
  }

  renderWeaponSelectorGrid(searchQuery = '', typeFilter = 'all', tierFilter = 'all') {
    const grid = document.getElementById('weapon-selector-grid');
    if (!grid) return;
    
    let filteredWeapons = state.weapons.filter(weapon => {
      // Filter by search query
      if (searchQuery && !weapon.weapon_name.toLowerCase().includes(searchQuery.toLowerCase())) {
        return false;
      }
      
      // Filter by weapon type
      if (typeFilter !== 'all' && weapon.weapon_type !== typeFilter) {
        return false;
      }
      
      // Filter by tier
      if (tierFilter !== 'all' && weapon.weapon_tier_id !== tierFilter) {
        return false;
      }
      
      return true;
    });
    
    filteredWeapons.sort((a, b) => a.weapon_name.localeCompare(b.weapon_name));
    
    grid.innerHTML = filteredWeapons.map(weapon => `
      <div class="card cursor-pointer hover:scale-105 transition-transform p-3" 
           onclick="app.selectWeapon('${weapon.weapon_id}')">
        ${weapon.image_url ? 
          `<img src="${weapon.image_url}" alt="${weapon.weapon_name}" class="w-full h-32 object-contain mb-2">` :
          '<div class="w-full h-32 bg-gray-800 rounded flex items-center justify-center mb-2"><span class="text-gray-600">No Image</span></div>'
        }
        <h4 class="font-bold text-sm text-tfd-primary mb-1">${weapon.weapon_name}</h4>
        <div class="text-xs text-gray-400">
          <div>${weapon.weapon_type}</div>
          <div>${weapon.weapon_tier_id?.replace('Tier', 'Tier ') || 'Unknown Tier'}</div>
        </div>
      </div>
    `).join('');
    
    const countEl = document.getElementById('weapon-count');
    if (countEl) {
      countEl.textContent = `${filteredWeapons.length} weapons`;
    }
  }

  selectWeapon(weaponId) {
    console.log('selectWeapon called with:', weaponId);
    console.log('currentWeaponSlot:', state.currentWeaponSlot);
    console.log('Available weapons:', state.weapons.length);
    
    if (!state.currentWeaponSlot || state.currentWeaponSlot.type !== 'weapon') {
      console.error('Invalid weapon slot state');
      return;
    }
    
    const weapon = state.weapons.find(w => w.weapon_id === weaponId);
    console.log('Found weapon:', weapon);
    
    if (!weapon) {
      console.error('Weapon not found:', weaponId);
      return;
    }
    
    const weaponIndex = state.currentWeaponSlot.index;
    state.currentBuild.weapons[weaponIndex].weapon = weapon;
    console.log('Weapon assigned to slot', weaponIndex);
    
    this.closeWeaponSelector();
    this.renderWeapons();
  }

  filterWeapons() {
    const searchInput = document.getElementById('weapon-search');
    const searchQuery = searchInput ? searchInput.value : '';
    
    const activeTypeFilter = document.querySelector('.module-filter-btn.active[data-weapon-type]');
    const typeFilter = activeTypeFilter ? activeTypeFilter.dataset.weaponType : 'all';
    
    const activeTierFilter = document.querySelector('.module-filter-btn.active[data-weapon-tier]');
    const tierFilter = activeTierFilter ? activeTierFilter.dataset.weaponTier : 'all';
    
    this.renderWeaponSelectorGrid(searchQuery, typeFilter, tierFilter);
  }

  filterWeaponsByType(type) {
    document.querySelectorAll('.module-filter-btn[data-weapon-type]').forEach(btn => {
      if (btn.dataset.weaponType === type) {
        btn.classList.add('active');
      } else {
        btn.classList.remove('active');
      }
    });
    this.filterWeapons();
  }

  filterWeaponsByTier(tier) {
    document.querySelectorAll('.module-filter-btn[data-weapon-tier]').forEach(btn => {
      if (btn.dataset.weaponTier === tier) {
        btn.classList.add('active');
      } else {
        btn.classList.remove('active');
      }
    });
    this.filterWeapons();
  }

  openWeaponModuleSelector(weaponIndex, moduleIndex) {
    const weaponData = state.currentBuild.weapons[weaponIndex];
    if (!weaponData?.weapon) {
      alert('Please select a weapon first');
      return;
    }
    
    state.currentWeaponSlot = { 
      index: weaponIndex, 
      moduleIndex: moduleIndex,
      type: 'module'
    };
    
    const modal = document.getElementById('module-selector-modal');
    if (modal) {
      modal.classList.remove('hidden');
    }
    
    const slotInfo = document.getElementById('module-slot-info');
    if (slotInfo) {
      const weapon = weaponData.weapon;
      const countSpan = slotInfo.querySelector('#module-count');
      if (countSpan) {
        slotInfo.innerHTML = `${weapon.weapon_name} - Module Slot ${moduleIndex + 1} | <span id="module-count">Loading...</span>`;
      } else {
        slotInfo.textContent = `${weapon.weapon_name} - Module Slot ${moduleIndex + 1}`;
      }
    }
    
    const searchInput = document.getElementById('module-search');
    if (searchInput) {
      searchInput.value = '';
      searchInput.focus();
    }
    
    // Reset filters
    document.querySelectorAll('.module-filter-btn[data-socket]').forEach(btn => {
      btn.classList.remove('active');
    });
    document.querySelector('.module-filter-btn[data-socket="all"]')?.classList.add('active');
    
    document.querySelectorAll('.module-filter-btn[data-tier]').forEach(btn => {
      btn.classList.remove('active');
    });
    document.querySelector('.module-filter-btn[data-tier="all"]')?.classList.add('active');
    
    // Render weapon modules (filter by weapon_rounds_type)
    this.renderWeaponModuleSelectorGrid();
  }

  renderWeaponModuleSelectorGrid(searchQuery = '', socketFilter = 'all', tierFilter = 'all') {
    const grid = document.getElementById('module-selector-grid');
    if (!grid) return;
    
    const weaponData = state.currentBuild.weapons[state.currentWeaponSlot.index];
    const weapon = weaponData?.weapon;
    if (!weapon) return;
    
    // Convert weapon type to module format using metadata lookup
    const weaponTypeForModule = state.getWeaponTypeCode(weapon.weapon_type);
    if (!weaponTypeForModule) {
      console.warn('Unknown weapon type:', weapon.weapon_type);
      return;
    }
    
    // Filter modules for this weapon type
    let filteredModules = state.modules.filter(module => {
      // Only show modules that match the weapon's specific rounds type
      // Don't show General Rounds modules for specialized weapons
      if (module.module_class !== weapon.weapon_rounds_type) {
        return false;
      }
      
      // Check if module is available for this specific weapon type (if specified)
      if (module.available_weapon_type && module.available_weapon_type.length > 0) {
        if (!module.available_weapon_type.includes(weaponTypeForModule)) {
          return false;
        }
      }
      
      // Filter by search query
      if (searchQuery && !module.module_name.toLowerCase().includes(searchQuery.toLowerCase())) {
        return false;
      }
      
      // Filter by socket type
      if (socketFilter !== 'all' && module.module_socket_type !== socketFilter) {
        return false;
      }
      
      // Filter by tier
      if (tierFilter !== 'all' && module.module_tier_id !== tierFilter) {
        return false;
      }
      
      return true;
    });
    
    filteredModules.sort((a, b) => a.module_name.localeCompare(b.module_name));
    
    grid.innerHTML = filteredModules.map(module => `
      <div class="module-card cursor-pointer hover:scale-105 transition-transform" 
           data-module-id="${module.module_id}"
           onclick="app.selectWeaponModule('${module.module_id}')">
        <div class="relative">
          ${module.image_url 
            ? `<img src="${module.image_url}" alt="${module.module_name}" class="w-full h-32 object-cover rounded-t-lg">`
            : '<div class="w-full h-32 bg-gray-800 rounded-t-lg flex items-center justify-center"><span class="text-gray-600">No Image</span></div>'
          }
          <div class="absolute top-2 right-2 px-2 py-1 text-xs rounded ${
            module.module_socket_type === 'Almandine' ? 'bg-red-600' :
            module.module_socket_type === 'Malachite' ? 'bg-green-600' :
            module.module_socket_type === 'Cerulean' ? 'bg-blue-600' :
            module.module_socket_type === 'Xantic' ? 'bg-yellow-600' :
            module.module_socket_type === 'Rutile' ? 'bg-purple-600' :
            'bg-gray-500'
          }">
            ${module.module_socket_type || 'N/A'}
          </div>
        </div>
        <div class="p-3">
          <h4 class="font-bold text-sm mb-1 text-tfd-primary">${module.module_name}</h4>
          <div class="text-xs text-gray-400 space-y-1">
            ${module.module_tier_id ? `<div>${module.module_tier_id.replace('Tier', 'Tier ')}</div>` : ''}
            ${module.module_class ? `<div>${module.module_class}</div>` : ''}
            ${module.module_type ? `<div class="text-tfd-accent">Type: ${module.module_type}</div>` : ''}
          </div>
        </div>
      </div>
    `).join('');
    
    const countEl = document.getElementById('module-count');
    if (countEl) {
      countEl.textContent = `${filteredModules.length} modules`;
    }
  }

  selectWeaponModule(moduleId) {
    if (!state.currentWeaponSlot || state.currentWeaponSlot.type !== 'module') return;
    
    const module = state.modules.find(m => m.module_id === moduleId);
    if (!module) return;
    
    // Check module_type uniqueness for this weapon
    if (module.module_type) {
      const weaponData = state.currentBuild.weapons[state.currentWeaponSlot.index];
      const duplicateIndex = weaponData.modules.findIndex((m, idx) => 
        m && m.module_type === module.module_type && idx !== state.currentWeaponSlot.moduleIndex
      );
      
      if (duplicateIndex !== -1) {
        alert(`A module with type "${module.module_type}" is already equipped in Module Slot ${duplicateIndex + 1}. Only one module of each type is allowed per weapon.`);
        return;
      }
    }
    
    state.currentBuild.weapons[state.currentWeaponSlot.index].modules[state.currentWeaponSlot.moduleIndex] = module;
    
    this.closeModuleSelector();
    this.renderWeapons();
  }

  // Custom Stats Methods
  openCustomStatSelector(weaponIndex, statSlot) {
    const weaponData = state.currentBuild.weapons[weaponIndex];
    const weapon = weaponData?.weapon;
    if (!weapon) {
      alert('Please select a weapon first.');
      return;
    }
    
    state.currentWeaponSlot = { 
      index: weaponIndex, 
      statSlot: statSlot,
      type: 'customStat' 
    };
    
    const modal = document.getElementById('custom-stat-modal');
    if (modal) {
      modal.classList.remove('hidden');
    }
    
    const info = document.getElementById('custom-stat-info');
    if (info) {
      info.textContent = `${weapon.weapon_name} - Custom Stat Slot ${statSlot + 1}`;
    }
    
    // Clear inputs
    const searchInput = document.getElementById('stat-search');
    if (searchInput) {
      searchInput.value = '';
      searchInput.focus();
    }
    
    const valueInput = document.getElementById('custom-stat-value');
    if (valueInput) {
      valueInput.value = '';
    }
    
    // Pre-fill if editing existing stat
    const existingStat = weaponData.customStats[statSlot];
    if (existingStat) {
      if (valueInput) {
        valueInput.value = existingStat.stat_value;
      }
    }
    
    this.renderStatSelector();
  }

  closeCustomStatSelector() {
    const modal = document.getElementById('custom-stat-modal');
    if (modal) {
      modal.classList.add('hidden');
    }
    state.currentWeaponSlot = null;
    state.selectedStatId = null;
  }

  renderStatSelector(searchQuery = '') {
    const grid = document.getElementById('stat-selector-grid');
    if (!grid) return;
    
    // Filter weapon-relevant stats
    const filteredStats = state.stats.filter(stat => {
      // Filter by search query
      if (searchQuery && !stat.stat_name.toLowerCase().includes(searchQuery.toLowerCase())) {
        return false;
      }
      
      // Only show weapon-related stats (you can customize this filter)
      return stat.stat_name && stat.stat_id;
    });
    
    // Sort alphabetically
    filteredStats.sort((a, b) => a.stat_name.localeCompare(b.stat_name));
    
    const weaponData = state.currentBuild.weapons[state.currentWeaponSlot?.index];
    const existingStat = weaponData?.customStats[state.currentWeaponSlot?.statSlot];
    
    grid.innerHTML = filteredStats.map(stat => {
      const isSelected = state.selectedStatId === stat.stat_id || existingStat?.stat_id === stat.stat_id;
      return `
        <button 
          class="w-full text-left px-3 py-2 rounded transition-colors ${
            isSelected 
              ? 'bg-tfd-primary/20 border border-tfd-primary text-tfd-primary' 
              : 'bg-tfd-dark hover:bg-tfd-primary/10 border border-gray-700 text-gray-300'
          }"
          onclick="app.selectStat('${stat.stat_id}')">
          <div class="text-sm font-semibold">${stat.stat_name}</div>
          <div class="text-xs text-gray-500">ID: ${stat.stat_id}</div>
        </button>
      `;
    }).join('');
    
    if (filteredStats.length === 0) {
      grid.innerHTML = '<p class="text-center text-gray-500 py-4">No stats found</p>';
    }
  }

  filterStats() {
    const searchInput = document.getElementById('stat-search');
    const searchQuery = searchInput ? searchInput.value : '';
    this.renderStatSelector(searchQuery);
  }

  selectStat(statId) {
    state.selectedStatId = statId;
    this.renderStatSelector(document.getElementById('stat-search')?.value || '');
    
    // Focus on value input
    const valueInput = document.getElementById('custom-stat-value');
    if (valueInput) {
      valueInput.focus();
    }
  }

  saveCustomStat() {
    if (!state.currentWeaponSlot || state.currentWeaponSlot.type !== 'customStat') {
      return;
    }
    
    if (!state.selectedStatId) {
      alert('Please select a stat first.');
      return;
    }
    
    const valueInput = document.getElementById('custom-stat-value');
    const value = valueInput ? parseFloat(valueInput.value) : 0;
    
    if (isNaN(value) || value === 0) {
      alert('Please enter a valid stat value.');
      return;
    }
    
    const weaponIndex = state.currentWeaponSlot.index;
    const statSlot = state.currentWeaponSlot.statSlot;
    const weaponData = state.currentBuild.weapons[weaponIndex];
    
    // Ensure customStats array has 4 slots
    while (weaponData.customStats.length < 4) {
      weaponData.customStats.push(null);
    }
    
    weaponData.customStats[statSlot] = {
      stat_id: state.selectedStatId,
      stat_value: value
    };
    
    this.closeCustomStatSelector();
    this.renderWeapons();
  }

  removeCustomStat(weaponIndex, statSlot) {
    const weaponData = state.currentBuild.weapons[weaponIndex];
    weaponData.customStats[statSlot] = null;
    this.renderWeapons();
  }

  // Core Type Methods
  openCoreTypeSelector(weaponIndex) {
    const weaponData = state.currentBuild.weapons[weaponIndex];
    const weapon = weaponData?.weapon;
    if (!weapon || !weapon.available_core_slot || weapon.available_core_slot.length === 0) {
      alert('This weapon has no core slot available.');
      return;
    }
    
    // Get available core types for this weapon
    const coreSlotId = weapon.available_core_slot[0]; // Use first core slot
    const coreSlot = state.getCoreSlot(coreSlotId);
    
    if (!coreSlot || !coreSlot.available_core_type_id || coreSlot.available_core_type_id.length === 0) {
      alert('No core types available for this weapon.');
      return;
    }
    
    state.currentWeaponSlot = { index: weaponIndex, type: 'core' };
    
    const modal = document.getElementById('core-selector-modal');
    if (modal) {
      modal.classList.remove('hidden');
    }
    
    const slotInfo = document.getElementById('core-slot-info');
    if (slotInfo) {
      slotInfo.textContent = `${weapon.weapon_name} - Select core type and configure stats`;
    }
    
    this.renderCoreTypeSelector(coreSlot.available_core_type_id, weaponIndex);
  }

  closeCoreSelector() {
    const modal = document.getElementById('core-selector-modal');
    if (modal) {
      modal.classList.add('hidden');
    }
    state.currentWeaponSlot = null;
  }

  renderCoreTypeSelector(availableCoreTypeIds, weaponIndex) {
    const grid = document.getElementById('core-selector-grid');
    if (!grid) return;
    
    const weaponData = state.currentBuild.weapons[weaponIndex];
    
    grid.innerHTML = availableCoreTypeIds.map(coreTypeId => {
      const coreType = state.getCoreType(coreTypeId);
      if (!coreType) return '';
      
      const isSelected = weaponData.coreType === coreTypeId;
      
      return `
        <div class="card ${isSelected ? 'border-tfd-primary' : ''} p-4">
          <h4 class="font-bold text-tfd-primary mb-3">${coreType.core_type}</h4>
          
          ${coreType.core_option && coreType.core_option.length > 0 ? `
            <div class="space-y-3">
              ${coreType.core_option.map((option, optionIndex) => {
                // Get all unique stats from all detail levels
                const allStats = new Map();
                option.detail?.forEach(detail => {
                  detail.available_item_option?.forEach(itemOption => {
                    if (!allStats.has(itemOption.option_effect.stat_id)) {
                      allStats.set(itemOption.option_effect.stat_id, {
                        stat_id: itemOption.option_effect.stat_id,
                        stat_name: itemOption.item_option,
                        operator_type: itemOption.option_effect.operator_type
                      });
                    }
                  });
                });
                
                const statsArray = Array.from(allStats.values());
                
                if (statsArray.length === 0) return '';
                
                return `
                  <div class="bg-tfd-darker p-3 rounded">
                    <div class="text-sm font-semibold text-gray-300 mb-2">Option ${optionIndex + 1}</div>
                    <div class="space-y-2">
                      ${statsArray.map(stat => {
                        const existingCoreStat = weaponData.coreStats.find(cs => 
                          cs.stat_id === stat.stat_id && cs.option_id === option.core_option_id
                        );
                        
                        return `
                          <div class="flex items-center gap-2">
                            <input 
                              type="checkbox" 
                              id="core_${coreTypeId}_${option.core_option_id}_${stat.stat_id}"
                              class="w-4 h-4"
                              ${existingCoreStat ? 'checked' : ''}
                              onchange="app.toggleCoreStat('${coreTypeId}', '${option.core_option_id}', '${stat.stat_id}', this.checked)"
                            >
                            <label class="text-xs text-gray-400 flex-1" for="core_${coreTypeId}_${option.core_option_id}_${stat.stat_id}">
                              ${stat.stat_name}
                            </label>
                            <input 
                              type="number" 
                              step="0.01"
                              placeholder="Value"
                              value="${existingCoreStat?.stat_value || ''}"
                              class="w-20 px-2 py-1 text-xs bg-tfd-dark border border-gray-600 rounded text-tfd-primary"
                              ${existingCoreStat ? '' : 'disabled'}
                              onchange="app.updateCoreStatValue('${coreTypeId}', '${option.core_option_id}', '${stat.stat_id}', this.value)"
                            >
                          </div>
                        `;
                      }).join('')}
                    </div>
                  </div>
                `;
              }).join('')}
            </div>
            
            <button 
              class="btn-primary w-full mt-4" 
              onclick="app.selectCoreType('${coreTypeId}', ${weaponIndex})">
              ${isSelected ? 'Update Core' : 'Select Core'}
            </button>
          ` : '<div class="text-xs text-gray-500">No options available</div>'}
        </div>
      `;
    }).join('');
  }

  toggleCoreStat(coreTypeId, optionId, statId, checked) {
    if (!state.currentWeaponSlot || state.currentWeaponSlot.type !== 'core') return;
    
    const weaponIndex = state.currentWeaponSlot.index;
    const weaponData = state.currentBuild.weapons[weaponIndex];
    
    // Set core type if not already set
    if (!weaponData.coreType) {
      weaponData.coreType = coreTypeId;
    }
    
    if (checked) {
      // Add stat if not already present
      const existingIndex = weaponData.coreStats.findIndex(cs => 
        cs.stat_id === statId && cs.option_id === optionId
      );
      
      if (existingIndex === -1) {
        weaponData.coreStats.push({
          option_id: optionId,
          stat_id: statId,
          stat_value: 0
        });
      }
      
      // Enable the input field
      const input = document.querySelector(`input[type="number"][onchange*="'${coreTypeId}', '${optionId}', '${statId}'"]`);
      if (input) input.disabled = false;
    } else {
      // Remove stat
      weaponData.coreStats = weaponData.coreStats.filter(cs => 
        !(cs.stat_id === statId && cs.option_id === optionId)
      );
      
      // Disable the input field
      const input = document.querySelector(`input[type="number"][onchange*="'${coreTypeId}', '${optionId}', '${statId}'"]`);
      if (input) {
        input.disabled = true;
        input.value = '';
      }
    }
  }

  updateCoreStatValue(coreTypeId, optionId, statId, value) {
    if (!state.currentWeaponSlot || state.currentWeaponSlot.type !== 'core') return;
    
    const weaponIndex = state.currentWeaponSlot.index;
    const weaponData = state.currentBuild.weapons[weaponIndex];
    
    const coreStat = weaponData.coreStats.find(cs => 
      cs.stat_id === statId && cs.option_id === optionId
    );
    
    if (coreStat) {
      coreStat.stat_value = parseFloat(value) || 0;
    }
  }

  selectCoreType(coreTypeId, weaponIndex) {
    const weaponData = state.currentBuild.weapons[weaponIndex];
    weaponData.coreType = coreTypeId;
    
    this.closeCoreSelector();
    this.renderWeapons();
  }
}

// Initialize the application
const app = new Application();

// Make app globally available for HTML onclick handlers
window.app = app;

// Start the application when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', () => app.init());
} else {
  app.init();
}

// Export for module usage
export default app;
